import csv
import numpy as np
from aero_funcs import checkRe
import matplotlib.pyplot as plt
from matplotlib import animation


# define problem parameters, these need to be in the SI
L = 0.050  # semi-height
alpha = 1  # wave-number
lam = 2 * np.pi * L  # wavelength
Red = 10000  # design Reynolds
nu = 5 * 10 ** (-6)  # viscosity
U = 0.17  # velocity

# the function checkRe is defined in the aero file, the arguments need to be strictly in this order
Re, U, L, nu = checkRe(Red, U, 2 * L, nu)
L = L / 2

cr = []
ci = []
# imports the eigenvalues in two arrays, one for the real component and one for the imaginary one
with open('mat.csv', ) as f:
    csvReader = csv.reader(f)
    for row in csvReader:
        cr.append(complex(row[0]))
        ci.append(complex(row[1]))

# now we create two arrays, one for time and one for space, both of length k
k = 1001
max_X = 50*L  # how much of the pipe we want to visualize
t_real = np.linspace(0, 5 * np.pi, k)
t = t_real.astype('complex')
x = np.linspace(0, max_X, k).astype('complex')

# generates a matrix in which each row is a solution with a different mode, each sol{i}.csv file is generated by orr_som
# _sol.py
sol = np.empty([len(cr), k]).astype('complex')

for i in range(len(cr)):
    sol[i, :] = np.genfromtxt(f'sol/sol{i}.csv', delimiter=',', dtype=str).astype('complex')
    sol[i, :] = np.complex_(sol[i, :])


# these are needed purely for aesthetic reasons, to determine the y-axis
max_Y = sol.max()
min_Y = sol.min()

# saves all the solutions and the x vector in one matrix: row 0 is the x coordinate, row 1 contains the solution number
# 0 and so on until the last solution
# dataSet = np.empty([len(cr)+1, k]).astype('complex')
# for i in range(len(cr)):
#     if i == 0:
#         dataSet[i, :] = x
#     else:
#         dataSet[i, :] = sol[i-1, :]

# number of modes to represent - 1
o = 7  # NOTE: these must be consecutive ones

sol_sum = np.empty_like(t)
for i in range(k):
    for j in range(len(cr)-1):
        sol_sum[i] = sol_sum[i] + sol[j, i]

dataSet = np.array([x, sol_sum])
# # TESTING ONLY
# sol1 = sol[9, :].astype('complex')
# dataSet = np.array(x, sol1).astype('complex')
# # END OF TEST

dataSet
# needed in animation.FuncAnimation()
def anim_func(num):
    # deletes previous images
    # ax.clear()
    # plots the i-esim point
    # for i in range(o):
    ax.plot(dataSet[0, :num+1], dataSet[1, :num+1])  # , c='blue')
    # set superior and inferior bounds
    ax.set_xlim(0, max_X)
    ax.set_ylim(min_Y*10, max_Y*25)

    # Adding Figure Labels
    ax.set_title('Waves \nTime = ' + str(np.round(t_real[num],
                                                  decimals=2)) + ' sec')
    ax.set_xlabel('x')
    ax.set_ylabel('amplitude')


fig = plt.figure()
ax = plt.axes()
line_ani = animation.FuncAnimation(fig, anim_func, interval=0.0001, frames=k)
plt.show()
myWriter = animation.FFMpegWriter(fps=60)
line_ani.save('test.mp4', writer=myWriter)
